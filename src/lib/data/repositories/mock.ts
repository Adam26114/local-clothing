import { BRAND } from '@/lib/constants';
import {
  categories as seedCategories,
  inventoryAuditLogs as seedInventoryAuditLogs,
  products as seedProducts,
  storeSettings as seedStoreSettings,
} from '@/lib/mock-data';
import type {
  Category,
  InventoryAuditLog,
  Product,
  SizeKey,
  StoreSettings,
  VariantMeasurement,
} from '@/lib/types';

import type {
  CategoryRepository,
  DataRepositories,
  InventoryRepository,
  ProductRepository,
  UpdateStockInput,
  InventoryRow,
  SettingsRepository,
} from '@/lib/data/repositories/types';

function deepClone<T>(value: T): T {
  return JSON.parse(JSON.stringify(value)) as T;
}

const state: {
  categories: Category[];
  products: Product[];
  storeSettings: StoreSettings;
  inventoryAuditLogs: InventoryAuditLog[];
} = {
  categories: deepClone(seedCategories),
  products: deepClone(seedProducts),
  storeSettings: deepClone(seedStoreSettings),
  inventoryAuditLogs: deepClone(seedInventoryAuditLogs),
};

function randomSuffix(): string {
  return Math.random().toString(36).slice(2, 8);
}

function toSlug(value: string): string {
  return value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-');
}

function ensureUniqueSlug(base: string, currentId?: string): string {
  const clean = toSlug(base) || `product-${randomSuffix()}`;
  let candidate = clean;
  let index = 1;

  while (
    state.products.some((product) => product.slug === candidate && product._id !== currentId)
  ) {
    candidate = `${clean}-${index}`;
    index += 1;
  }

  return candidate;
}

function normalizeVariantMeasurements(
  measurements: Product['colorVariants'][number]['measurements']
): Partial<Record<SizeKey, VariantMeasurement>> | undefined {
  if (!measurements) return undefined;
  return measurements;
}

function categoryChildrenIds(parentId: string): string[] {
  return state.categories.filter((item) => item.parentId === parentId).map((item) => item._id);
}

function publishedProducts(): Product[] {
  return state.products.filter((item) => item.isPublished);
}

function filterByCategorySlug(categorySlug: string, products: Product[]): Product[] {
  if (categorySlug === 'sale') {
    return products.filter((item) => {
      const base = item.basePrice ?? 0;
      const sale = item.salePrice ?? 0;
      return sale > 0 && sale < base;
    });
  }

  if (categorySlug === 'new') {
    const newCategory = state.categories.find((item) => item.slug === 'new' && !item.parentId);
    if (!newCategory) {
      return products;
    }
    return products.filter((item) => item.categoryId === newCategory._id);
  }

  const category = state.categories.find((item) => item.slug === categorySlug && !item.parentId);
  if (!category) {
    return products;
  }

  const childIds = categoryChildrenIds(category._id);
  if (childIds.length === 0) {
    return products.filter((item) => item.categoryId === category._id);
  }

  return products.filter((item) => childIds.includes(item.categoryId));
}

function findInventoryRow(productId: string, variantId: string, size: SizeKey): InventoryRow {
  const product = state.products.find((entry) => entry._id === productId);
  if (!product) {
    throw new Error('Product not found while resolving inventory row.');
  }

  const variant = product.colorVariants.find((entry) => entry.id === variantId);
  if (!variant) {
    throw new Error('Variant not found while resolving inventory row.');
  }

  return {
    productId: product._id,
    productName: product.name,
    variantId,
    colorName: variant.colorName,
    size,
    stock: variant.stock[size] ?? 0,
    isPublished: product.isPublished,
  };
}

function createProductRepository(): ProductRepository {
  return {
    async list(options) {
      const items = options?.publishedOnly ? publishedProducts() : state.products;
      return deepClone(items);
    },

    async listFeatured() {
      const featured = publishedProducts().filter((item) => item.isFeatured);
      return deepClone(featured);
    },

    async listByCategorySlug(categorySlug) {
      return deepClone(filterByCategorySlug(categorySlug, publishedProducts()));
    },

    async listBySubcategorySlugs(categorySlug, subcategorySlug) {
      const parent = state.categories.find((item) => item.slug === categorySlug && !item.parentId);
      if (!parent) return [];

      const subcategory = state.categories.find(
        (item) => item.slug === subcategorySlug && item.parentId === parent._id
      );

      if (!subcategory) return [];

      return deepClone(
        publishedProducts().filter((product) => product.categoryId === subcategory._id)
      );
    },

    async listRelatedBySlug(slug, limit = 4) {
      const related = publishedProducts()
        .filter((item) => item.slug !== slug)
        .slice(0, limit);
      return deepClone(related);
    },

    async getById(id) {
      const product = state.products.find((item) => item._id === id);
      return product ? deepClone(product) : undefined;
    },

    async getBySlug(slug, options) {
      const publishedOnly = options?.publishedOnly ?? true;
      const product = state.products.find((item) => {
        if (item.slug !== slug) return false;
        if (publishedOnly) return item.isPublished;
        return true;
      });

      return product ? deepClone(product) : undefined;
    },

    async create(input) {
      const now = Date.now();
      const product: Product = {
        ...input,
        _id: `prod-${randomSuffix()}`,
        slug: ensureUniqueSlug(input.slug || input.name),
        colorVariants: input.colorVariants.map((variant) => ({
          ...variant,
          id: variant.id || `variant-${randomSuffix()}`,
          measurements: normalizeVariantMeasurements(variant.measurements),
        })),
        createdAt: now,
        updatedAt: now,
      };

      state.products.unshift(product);
      return deepClone(product);
    },

    async update(id, input) {
      const index = state.products.findIndex((item) => item._id === id);
      if (index < 0) {
        throw new Error('Product not found.');
      }

      const existing = state.products[index];
      const updated: Product = {
        ...existing,
        ...input,
        _id: id,
        slug: ensureUniqueSlug(input.slug || input.name || existing.name, id),
        colorVariants: input.colorVariants.map((variant) => ({
          ...variant,
          id: variant.id || `variant-${randomSuffix()}`,
          measurements: normalizeVariantMeasurements(variant.measurements),
        })),
        updatedAt: Date.now(),
      };

      state.products[index] = updated;
      return deepClone(updated);
    },

    async softDelete(id) {
      const product = state.products.find((item) => item._id === id);
      if (!product) return;
      product.isPublished = false;
      product.updatedAt = Date.now();
    },

    async duplicate(id) {
      const original = state.products.find((item) => item._id === id);
      if (!original) {
        throw new Error('Product not found.');
      }

      const now = Date.now();
      const duplicate: Product = {
        ...deepClone(original),
        _id: `prod-${randomSuffix()}`,
        name: `${original.name} (Copy)`,
        slug: ensureUniqueSlug(`${original.slug}-copy`),
        sku: original.sku ? `${original.sku}-COPY` : undefined,
        colorVariants: original.colorVariants.map((variant) => ({
          ...deepClone(variant),
          id: `${variant.id}-copy-${randomSuffix()}`,
        })),
        createdAt: now,
        updatedAt: now,
      };

      state.products.unshift(duplicate);
      return deepClone(duplicate);
    },

    async toggleBulkStatus(ids, isPublished) {
      const idSet = new Set(ids);
      let updated = 0;

      for (const product of state.products) {
        if (!idSet.has(product._id)) continue;
        product.isPublished = isPublished;
        product.updatedAt = Date.now();
        updated += 1;
      }

      return updated;
    },
  };
}

function createCategoryRepository(): CategoryRepository {
  return {
    async list(options) {
      const rows = state.categories
        .filter((item) => (options?.activeOnly === false ? true : item.isActive))
        .sort((a, b) => a.sortOrder - b.sortOrder);
      return deepClone(rows);
    },
  };
}

function createSettingsRepository(): SettingsRepository {
  return {
    async get() {
      return deepClone({
        ...state.storeSettings,
        contactEmail: state.storeSettings.contactEmail ?? BRAND.contactEmail,
        contactPhone: state.storeSettings.contactPhone ?? BRAND.contactPhone,
        pickupAddress: state.storeSettings.pickupAddress ?? BRAND.pickupAddress,
        pickupHours: state.storeSettings.pickupHours ?? BRAND.pickupHours,
      });
    },
  };
}

function createInventoryRepository(): InventoryRepository {
  return {
    async listFlattened() {
      const rows: InventoryRow[] = [];

      for (const product of state.products) {
        for (const variant of product.colorVariants) {
          for (const size of variant.selectedSizes) {
            rows.push({
              productId: product._id,
              productName: product.name,
              variantId: variant.id,
              colorName: variant.colorName,
              size,
              stock: variant.stock[size] ?? 0,
              isPublished: product.isPublished,
            });
          }
        }
      }

      return rows.sort((a, b) => a.productName.localeCompare(b.productName));
    },

    async updateStock(input: UpdateStockInput) {
      const product = state.products.find((entry) => entry._id === input.productId);
      if (!product) {
        throw new Error('Product not found.');
      }

      const variant = product.colorVariants.find((entry) => entry.id === input.variantId);
      if (!variant) {
        throw new Error('Variant not found.');
      }

      const oldValue = variant.stock[input.size] ?? 0;
      const newValue = Math.max(0, Math.floor(input.newValue));

      variant.stock[input.size] = newValue;
      if (!variant.selectedSizes.includes(input.size)) {
        variant.selectedSizes.push(input.size);
      }
      product.updatedAt = Date.now();

      const log: InventoryAuditLog = {
        _id: `log-${randomSuffix()}`,
        productId: product._id,
        variantId: variant.id,
        size: input.size,
        oldValue,
        newValue,
        changedBy: input.changedBy,
        changedAt: Date.now(),
      };

      state.inventoryAuditLogs.unshift(log);

      return {
        row: deepClone(findInventoryRow(product._id, variant.id, input.size)),
        log: deepClone(log),
      };
    },

    async listAuditLogs(input) {
      const logs = state.inventoryAuditLogs
        .filter((entry) => {
          if (input.productId && entry.productId !== input.productId) return false;
          if (input.variantId && entry.variantId !== input.variantId) return false;
          if (input.size && entry.size !== input.size) return false;
          return true;
        })
        .sort((a, b) => b.changedAt - a.changedAt)
        .slice(0, input.limit ?? 50);

      return deepClone(logs);
    },
  };
}

export function createMockRepositories(): DataRepositories {
  return {
    products: createProductRepository(),
    categories: createCategoryRepository(),
    settings: createSettingsRepository(),
    inventory: createInventoryRepository(),
  };
}
